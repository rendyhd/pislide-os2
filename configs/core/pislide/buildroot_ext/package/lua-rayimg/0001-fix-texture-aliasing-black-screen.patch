From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Claude <noreply@anthropic.com>
Date: Mon, 02 Dec 2025 00:00:00 +0000
Subject: [PATCH] fix: Prevent black screen between slideshow cycles

This patch fixes a critical black screen bug that occurs between slideshow
cycles, and improves caching to prevent slow reloads.

Key changes:

1. New preload_next_image() function that:
   - Cleans up existing next_texture before loading new one
   - Uses pcall for error handling to prevent crashes
   - Falls back gracefully on load failures

2. Early preloading at startup to use full display time for loading

3. Graceful transition check - only transitions when next image is ready,
   extends display time if image not loaded yet

4. CRITICAL FIX: Set next_texture = nil after assigning to loaded_texture
   to prevent the cleanup in preload_next_image() from unloading the
   texture that loaded_texture is still displaying

5. CRITICAL FIX: Call drawSingleImage() BEFORE preload_next_image() to
   ensure the current image is displayed during the blocking load,
   preventing blank/blue screen on DRM/KMS displays

6. CACHING FIX: Always cache images regardless of size to prevent slow
   reloads on subsequent cycles

---
 rayimg/build/rayimg/imageloader/raylib_image.lua |  5 +--
 rayimg/build/rayimg/imageloader/vips_image.lua   |  5 +--
 rayimg/build/rayimg/main.lua                     | 68 +++++++++++++++++-------
 3 files changed, 55 insertions(+), 23 deletions(-)

diff --git a/rayimg/build/rayimg/imageloader/raylib_image.lua b/rayimg/build/rayimg/imageloader/raylib_image.lua
--- a/rayimg/build/rayimg/imageloader/raylib_image.lua
+++ b/rayimg/build/rayimg/imageloader/raylib_image.lua
@@ -13,13 +13,13 @@

 function RaylibImageLoader.load_image_and_downsize(file, screen_width, screen_height)
    local image = rl.LoadImage(file)
-   local should_cache = false
+   -- Always cache to prevent slow reloads on subsequent cycles
+   local should_cache = true
    if image.width > screen_width or image.height > screen_height then
       local scale = math.min(screen_width / image.width, screen_height / image.height)
       local newWidth = math.min(screen_width, scale * image.width)
       local newHeight = math.min(screen_height, scale * image.height)
       rl.ImageResize(image, math.floor(newWidth), math.floor(newHeight))
-      should_cache = true
    end

    local mt = { __gc = function(self) print("raylib gc called"); rl.UnloadImage(self.image) end }
diff --git a/rayimg/build/rayimg/imageloader/vips_image.lua b/rayimg/build/rayimg/imageloader/vips_image.lua
--- a/rayimg/build/rayimg/imageloader/vips_image.lua
+++ b/rayimg/build/rayimg/imageloader/vips_image.lua
@@ -14,12 +14,12 @@
 function VipsImageLoader.load_image_and_downsize(file, screen_width, screen_height)
    local vips_image = vips.Image.new_from_file(file)

-   local should_cache = false
+   -- Always cache to prevent slow reloads on subsequent cycles
+   local should_cache = true

    if vips_image:width() > screen_width or vips_image:height() > screen_height then
       local scale = math.min(screen_width / vips_image:width(), screen_height / vips_image:height())
       vips_image = vips_image:resize(scale, { kernel = "lanczos3" })
-      should_cache = true
    end

    if vips_image:interpretation() ~= "srgb" then
diff --git a/rayimg/build/rayimg/main.lua b/rayimg/build/rayimg/main.lua
--- a/rayimg/build/rayimg/main.lua
+++ b/rayimg/build/rayimg/main.lua
@@ -61,11 +61,6 @@
 local loaded_texture = image_handler:get_current_image()
 local next_texture

-
-if args.transition_duration > 0 then
-   next_texture = image_handler:peek_next_image()
-end
-
 local timer_duration = 0
 local transitioning = false
 local transition_time = 0
@@ -77,6 +72,29 @@
    transition_time = 0
 end

+-- Helper function to pre-load next image with proper cleanup
+local function preload_next_image()
+   if args.transition_duration > 0 then
+      -- Clean up old next_texture if it exists
+      if next_texture ~= nil then
+         rl.UnloadTexture(next_texture.texture)
+      end
+      collectgarbage()
+
+      -- Load next image (this may take time, but we do it early)
+      local success, result = pcall(image_handler.peek_next_image, image_handler)
+      if success then
+         next_texture = result
+      else
+         print("WARNING: Failed to pre-load next image: " .. tostring(result))
+         next_texture = nil
+      end
+   end
+end
+
+-- Pre-load the first next_texture at startup (during initial display time)
+preload_next_image()
+
 local function drawText()
    if args.display == "none" then
       return
@@ -106,6 +124,10 @@
       image_handler:increase_index()
       loaded_texture = image_handler:get_current_image()
       reset_timers()
+      -- Draw current image BEFORE preloading to prevent blank screen during load
+      drawSingleImage()
+      -- Pre-load next image immediately to use full display time for loading
+      preload_next_image()
    end

    if rl.IsKeyPressed(rl.KEY_LEFT) then
@@ -113,12 +135,23 @@
       image_handler:decrease_index()
       loaded_texture = image_handler:get_current_image()
       reset_timers()
+      -- Draw current image BEFORE preloading to prevent blank screen during load
+      drawSingleImage()
+      -- Pre-load next image immediately (preload_next_image handles cleanup)
+      preload_next_image()
    end

    if args.duration > 0 then
       if timer_duration >= args.duration then
-         transitioning = true
-         rl.SetTargetFPS(20)
+         -- Only transition if next image is ready (graceful fallback)
+         if args.transition_duration == 0 or next_texture ~= nil then
+            transitioning = true
+            rl.SetTargetFPS(20)
+         else
+            -- Next image not ready yet, extend display time
+            -- This prevents black screen - better to show current image longer
+            print("INFO: Next image not loaded yet, extending display time...")
+         end
       end
       timer_duration = timer_duration + rl.GetFrameTime()
    end
@@ -141,16 +174,27 @@

          image_handler:increase_index()
          loaded_texture = next_texture
+         -- CRITICAL: Clear next_texture reference before preload_next_image()
+         -- to prevent unloading the texture we just assigned to loaded_texture
+         next_texture = nil

-         next_texture = image_handler:peek_next_image()
          reset_timers()
+
+         -- Draw current image BEFORE preloading to prevent blank screen during load
+         drawSingleImage()
+
+         -- Pre-load next image immediately to use full display time for loading
+         preload_next_image()
       end
    elseif transitioning then
+      -- No transition effect, just switch immediately
       rl.UnloadTexture(loaded_texture.texture)
       image_handler:increase_index()
       loaded_texture = image_handler:get_current_image()
       reset_timers()
       drawSingleImage()
+      -- Pre-load next image for next cycle
+      preload_next_image()
    elseif loaded_texture.image.kind == "animation" then
       rl.SetTargetFPS(math.floor(1000 / (loaded_texture.image).advance_frame()))
       rl.UpdateTexture(loaded_texture.texture, (loaded_texture.image).get_frame_pixels())
